(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{108:function(e,n,t){e.exports=t(221)},221:function(e,n,t){"use strict";t.r(n);var r=t(0),a=t.n(r),i=t(26),c=t.n(i),l=t(10),o=t(9),u=t(103),m=t.n(u),s=t(49),f=t(48),d=t.n(f),v=t(106),g=t(50),p=t(28),b=t(13),S=function(e){return new Promise(function(n,t){var r=new FileReader;r.onerror=t,r.onload=function(){r.result?n(r.result):t("File does not exist.")},r.readAsDataURL(e)})},j=function(e){return new Promise(function(n){var t=new Image;t.onload=function(){n(t.naturalWidth/t.naturalHeight)},t.src=e})},k=function(e,n){var t=document.createElement("a");t.download=n,t.href=e.replace(/^data:image\/[^;]+/,"data:application/octet-stream"),document.body.appendChild(t),t.click(),document.body.removeChild(t)},h=t(4),x="\n  #ifdef GL_ES\n  precision mediump float;\n  precision mediump int;\n  #endif\n\n  #define SIGMA 5.0\n  #define BSIGMA 0.3\n  #define MSIZE 5\n\n  varying vec2 vTextureCoord;\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n\n  float normpdf(in float x, in float sigma)\n  {\n    return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n  }\n\n  float normpdf3(in vec3 v, in float sigma)\n  {\n    return 0.39894*exp(-0.5*dot(v,v)/(sigma*sigma))/sigma;\n  }\n\n  void main(void)\n  {\n    vec3 c = texture2D(uSampler, vTextureCoord).rgb;\n\n    //declare stuff\n    const int kSize = (MSIZE-1)/2;\n    float kernel[MSIZE];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n      kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n    }\n\n    vec3 cc;\n    float factor;\n    float bZ = 1.0/normpdf(0.0, BSIGMA);\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n      for (int j=-kSize; j <= kSize; ++j)\n      {\n        cc = texture2D(uSampler, vec2(0.0, 0.0) + ( vTextureCoord + vec2(float(i),float(j)) / resolution ) ).rgb;\n        factor = normpdf3(cc-c, BSIGMA)*bZ*kernel[kSize+j]*kernel[kSize+i];\n        Z += factor;\n        final_color += factor*cc;\n      }\n    }\n\n    gl_FragColor = vec4(final_color/Z, 1.0);\n  }\n",w='\n  #ifdef GL_ES\n  precision mediump float;\n  precision mediump int;\n  #endif\n\n  varying vec2 vTextureCoord;\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n\n  #define RADIUS 3\n\n  void main (void) {\n\n    // Bildkoordinaten des aktuellen Pixels -> (u,v) von 0 .. 1\n    vec2 src_size = vec2(resolution.x, resolution.y);\n    vec2 uv = vTextureCoord;\n\n    // Anzahl der Pixel einer Region\n    float n = float((RADIUS + 1) * (RADIUS + 1));\n\n    // Summen und Summenquadrate der Regionen (in Burger: (17.4 S_1,k, 17.5 S_2,k)\n    // Zu beachten: Jeweils Vektoren mit 3 Elementen f\xfcr die einzelnen Farbkan\xe4le RGB\n    vec3 m[4];\n    vec3 s[4];\n    for (int k = 0; k < 4; ++k) {\n      m[k] = vec3(0.0);\n      s[k] = vec3(0.0);\n    }\n\n    for (int t = -RADIUS; t <= 0; ++t) {\n      for (int i = -RADIUS; i <= 0; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,t) / src_size).rgb;\n        m[0] += c;\n        s[0] += c * c;\n      }\n    }\n\n    for (int j = -RADIUS; j <= 0; ++j) {\n      for (int i = 0; i <= RADIUS; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[1] += c;\n        s[1] += c * c;\n      }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j) {\n      for (int i = 0; i <= RADIUS; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[2] += c;\n        s[2] += c * c;\n      }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j) {\n      for (int i = -RADIUS; i <= 0; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[3] += c;\n        s[3] += c * c;\n      }\n    }\n\n    // Region mit der kleinsten Varianz finden und deren Mittelwert als neuen Pixelwert nutzen\n\n    float min_sigma2 = 100.0;\n    for (int k = 0; k < 4; ++k) {\n\n      // Tats\xe4chliche Mittelwerte und Varianzen der Regionen berechnen\n      // Analog zu (17.3) in Burger\n      m[k] /= n;\n      s[k] = abs(s[k] / n - m[k] * m[k]);\n\n      // "Totale Varianz"\n      float sigma2 = s[k].r + s[k].g + s[k].b;\n\n      if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        // Neuen Pixelwert setzen\n        gl_FragColor = vec4(m[k], 1.0);\n      }\n    }\n  }\n';function E(){var e=Object(l.a)(["\n  margin-top: 10px;\n"]);return E=function(){return e},e}function O(){var e=Object(l.a)(["\n  padding: 40px 0;\n"]);return O=function(){return e},e}function z(){var e=Object(l.a)(["\n  > div {\n    margin: 0 10px;\n  }\n"]);return z=function(){return e},e}function D(){var e=Object(l.a)(["\n  margin-bottom: 10px;\n"]);return D=function(){return e},e}function A(){var e=Object(l.a)(["\n  text-align: center;\n"]);return A=function(){return e},e}var I=o.default.div(A()),R=o.default.div(D()),_=o.default.div(z()),y=o.default.section(O()),F=o.default.div(E()),C={width:500,height:500};function M(){var e=Object(r.useState)(C),n=Object(p.a)(e,2),t=n[0],i=n[1],c=Object(r.useState)(null),l=Object(p.a)(c,2),o=l[0],u=l[1],m=Object(r.useState)(1),f=Object(p.a)(m,2),E=f[0],O=f[1],z=function(e){var n=e.width,t=e.height,a=Object(r.useMemo)(function(){return{resolution:{type:"v2",value:[n,t]}}},[n,t]);return{KuwaharaFilter:Object(r.useMemo)(function(){return new h.Filter("",w,a)},[a]),BilateralFilter:Object(r.useMemo)(function(){return new h.Filter("",x,a)},[a])}}(Object(g.a)({},t)),D=z.KuwaharaFilter,A=z.BilateralFilter,M=Object(r.useCallback)(function(){var e=Object(v.a)(d.a.mark(function e(n){var t,r,a;return d.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=Array.prototype.slice.call(n.target.files),e.prev=1,u(null),i(C),e.next=6,S(t[0]);case 6:return r=e.sent,u(r),e.next=10,j(r);case 10:a=e.sent,i(function(e){return Object(g.a)({},e,{width:e.width*a})}),e.next=17;break;case 14:e.prev=14,e.t0=e.catch(1),alert(e.t0.message);case 17:case"end":return e.stop()}},e,this,[[1,14]])}));return function(n){return e.apply(this,arguments)}}(),[]),B=Object(r.useCallback)(function(e){var n=e.currentTarget.previousElementSibling;if(n){var t=n.app,r=t.renderer.plugins.extract.base64(t.stage);k(r,"image.jpg")}else alert("Download failed")},[]),U=Object(r.useCallback)(function(e){var n=e.currentTarget.value;O(+n)},[]),G=Object(r.useMemo)(function(){return a.a.createElement(F,null,a.a.createElement("button",{onClick:B},"Download"))},[]);return a.a.createElement(a.a.Fragment,null,a.a.createElement(I,null,a.a.createElement(R,null,a.a.createElement("input",{type:"file",accept:"image/*",onChange:M}),a.a.createElement("label",null,"Pile: ",a.a.createElement("input",{type:"range",min:"1",max:"10",value:E,onChange:U}))),a.a.createElement(_,null,a.a.createElement(y,null,a.a.createElement("h2",null,"Before"),a.a.createElement(b.Stage,t,o&&a.a.createElement(b.Sprite,Object.assign({image:o},t)))),a.a.createElement(y,null,a.a.createElement("h2",null,"Kuwahara Filter"),a.a.createElement(b.Stage,t,o&&a.a.createElement(b.Sprite,Object.assign({image:o,filters:Object(s.a)(Array(E)).map(function(){return D})},t))),o&&G),a.a.createElement(y,null,a.a.createElement("h2",null,"Bilateral Filter"),a.a.createElement(b.Stage,t,o&&a.a.createElement(b.Sprite,Object.assign({image:o,filters:Object(s.a)(Array(E)).map(function(){return A})},t))),o&&G))))}function B(){var e=Object(l.a)(["\n  font-size: 36px;\n  font-weight: bold;\n  text-align: center;\n  line-height: 1.5;\n  padding: 24px 0;\n"]);return B=function(){return e},e}function U(){var e=Object(l.a)(["\n  ","\n"]);return U=function(){return e},e}Object(o.createGlobalStyle)(U(),m.a);var G=o.default.h1(B());Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));c.a.render(a.a.createElement(function(){return a.a.createElement(a.a.Fragment,null,a.a.createElement(G,null,"Image Filters"),a.a.createElement(M,null))},null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})}},[[108,2,1]]]);
//# sourceMappingURL=main.307dd6e2.chunk.js.map