{"version":3,"sources":["utils/index.ts","Filters/shader/index.js","Filters/styled.ts","Filters/index.tsx","Filters/hooks/useFilter.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["convertBlobToBase64","blob","Promise","resolve","reject","reader","FileReader","onerror","onload","result","readAsDataURL","getAspectRatioOfBase64","base64","image","Image","naturalWidth","naturalHeight","src","download","filename","anchor","document","createElement","href","replace","body","appendChild","click","removeChild","bilateral","kuwahara","Container","styled","div","_templateObject","InputSection","_templateObject2","FiltersSection","_templateObject3","FilterSection","section","_templateObject4","DownloadSection","_templateObject5","initialCanvasSize","width","height","Filter","_useState","useState","_useState2","Object","slicedToArray","canvasSize","setCanvasSize","_useState3","_useState4","setBase64","_useState5","_useState6","pile","setPile","_useFilter","_ref","uniforms","useMemo","resolution","type","value","KuwaharaFilter","PIXI","BilateralFilter","useFilter","objectSpread","handleFiles","useCallback","asyncToGenerator","regenerator_default","a","mark","_callee","event","files","_base64","aspectRatio","wrap","_context","prev","next","Array","prototype","slice","call","target","sent","t0","alert","message","stop","this","_x","apply","arguments","handleDownload","stageElement","currentTarget","previousElementSibling","app","renderer","plugins","extract","stage","handlePile","downloadButton","react_default","onClick","Fragment","accept","onChange","min","max","react_pixi_module","assign","filters","toConsumableArray","map","createGlobalStyle","App_templateObject","reset","Title","h1","App_templateObject2","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.307dd6e2.chunk.js","sourcesContent":["export const convertBlobToBase64 = (blob: Blob): Promise<any> =>\n  new Promise((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onerror = reject\n    reader.onload = () => {\n      if (reader.result) {\n        resolve(reader.result)\n      } else {\n        reject('File does not exist.')\n      }\n    }\n    reader.readAsDataURL(blob)\n  })\n\nexport const convertBase64ToBlob = (base64: string, mimeCtype: string) => {\n  const bom = new Uint8Array([0xef, 0xbb, 0xbf])\n  const bin = atob(base64.replace(/^.*,/, ''))\n  const buffer = new Uint8Array(bin.length)\n  for (let i = 0; i < bin.length; i++) {\n    buffer[i] = bin.charCodeAt(i)\n  }\n  try {\n    return new Blob([bom, buffer.buffer], {\n      type: mimeCtype,\n    })\n  } catch (e) {\n    console.log(e.message)\n  }\n}\n\nexport const getAspectRatioOfBase64 = (base64: string): Promise<number> =>\n  new Promise(resolve => {\n    const image = new Image()\n    image.onload = () => {\n      resolve(image.naturalWidth / image.naturalHeight)\n    }\n    image.src = base64\n  })\n\nexport const download = (base64: string, filename: string) => {\n  const anchor = document.createElement('a')\n  anchor.download = filename\n  anchor.href = base64.replace(/^data:image\\/[^;]+/, 'data:application/octet-stream')\n  document.body.appendChild(anchor)\n  anchor.click()\n  document.body.removeChild(anchor)\n}\n","export const bilateral = `\n  #ifdef GL_ES\n  precision mediump float;\n  precision mediump int;\n  #endif\n\n  #define SIGMA 5.0\n  #define BSIGMA 0.3\n  #define MSIZE 5\n\n  varying vec2 vTextureCoord;\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n\n  float normpdf(in float x, in float sigma)\n  {\n    return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n  }\n\n  float normpdf3(in vec3 v, in float sigma)\n  {\n    return 0.39894*exp(-0.5*dot(v,v)/(sigma*sigma))/sigma;\n  }\n\n  void main(void)\n  {\n    vec3 c = texture2D(uSampler, vTextureCoord).rgb;\n\n    //declare stuff\n    const int kSize = (MSIZE-1)/2;\n    float kernel[MSIZE];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n      kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n    }\n\n    vec3 cc;\n    float factor;\n    float bZ = 1.0/normpdf(0.0, BSIGMA);\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n      for (int j=-kSize; j <= kSize; ++j)\n      {\n        cc = texture2D(uSampler, vec2(0.0, 0.0) + ( vTextureCoord + vec2(float(i),float(j)) / resolution ) ).rgb;\n        factor = normpdf3(cc-c, BSIGMA)*bZ*kernel[kSize+j]*kernel[kSize+i];\n        Z += factor;\n        final_color += factor*cc;\n      }\n    }\n\n    gl_FragColor = vec4(final_color/Z, 1.0);\n  }\n`;\n\n// Portiert von https://github.com/MzHub/gpuakf/blob/master/glsl/kuwahara.glsl\nexport const kuwahara = `\n  #ifdef GL_ES\n  precision mediump float;\n  precision mediump int;\n  #endif\n\n  varying vec2 vTextureCoord;\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n\n  #define RADIUS 3\n\n  void main (void) {\n\n    // Bildkoordinaten des aktuellen Pixels -> (u,v) von 0 .. 1\n    vec2 src_size = vec2(resolution.x, resolution.y);\n    vec2 uv = vTextureCoord;\n\n    // Anzahl der Pixel einer Region\n    float n = float((RADIUS + 1) * (RADIUS + 1));\n\n    // Summen und Summenquadrate der Regionen (in Burger: (17.4 S_1,k, 17.5 S_2,k)\n    // Zu beachten: Jeweils Vektoren mit 3 Elementen für die einzelnen Farbkanäle RGB\n    vec3 m[4];\n    vec3 s[4];\n    for (int k = 0; k < 4; ++k) {\n      m[k] = vec3(0.0);\n      s[k] = vec3(0.0);\n    }\n\n    for (int t = -RADIUS; t <= 0; ++t) {\n      for (int i = -RADIUS; i <= 0; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,t) / src_size).rgb;\n        m[0] += c;\n        s[0] += c * c;\n      }\n    }\n\n    for (int j = -RADIUS; j <= 0; ++j) {\n      for (int i = 0; i <= RADIUS; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[1] += c;\n        s[1] += c * c;\n      }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j) {\n      for (int i = 0; i <= RADIUS; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[2] += c;\n        s[2] += c * c;\n      }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j) {\n      for (int i = -RADIUS; i <= 0; ++i) {\n        vec3 c = texture2D(uSampler, uv + vec2(i,j) / src_size).rgb;\n        m[3] += c;\n        s[3] += c * c;\n      }\n    }\n\n    // Region mit der kleinsten Varianz finden und deren Mittelwert als neuen Pixelwert nutzen\n\n    float min_sigma2 = 100.0;\n    for (int k = 0; k < 4; ++k) {\n\n      // Tatsächliche Mittelwerte und Varianzen der Regionen berechnen\n      // Analog zu (17.3) in Burger\n      m[k] /= n;\n      s[k] = abs(s[k] / n - m[k] * m[k]);\n\n      // \"Totale Varianz\"\n      float sigma2 = s[k].r + s[k].g + s[k].b;\n\n      if (sigma2 < min_sigma2) {\n        min_sigma2 = sigma2;\n        // Neuen Pixelwert setzen\n        gl_FragColor = vec4(m[k], 1.0);\n      }\n    }\n  }\n`;\n","import styled from 'styled-components'\n\nexport const Container = styled.div`\n  text-align: center;\n`\n\nexport const InputSection = styled.div`\n  margin-bottom: 10px;\n`\n\nexport const FiltersSection = styled.div`\n  > div {\n    margin: 0 10px;\n  }\n`\n\nexport const FilterSection = styled.section`\n  padding: 40px 0;\n`\n\nexport const DownloadSection = styled.div`\n  margin-top: 10px;\n`\n","import { Sprite, Stage } from '@inlet/react-pixi'\nimport React, { ChangeEvent, SyntheticEvent, useCallback, useMemo, useState } from 'react'\nimport { convertBlobToBase64, download, getAspectRatioOfBase64 } from '../utils'\nimport useFilter from './hooks/useFilter'\nimport { Container, DownloadSection, FilterSection, FiltersSection, InputSection } from './styled'\n\nconst initialCanvasSize = { width: 500, height: 500 }\n\nexport default function Filter() {\n  const [canvasSize, setCanvasSize] = useState(initialCanvasSize)\n  const [base64, setBase64] = useState<string | null>(null)\n  const [pile, setPile] = useState<number>(1)\n  const { KuwaharaFilter, BilateralFilter } = useFilter({ ...canvasSize })\n\n  const handleFiles = useCallback(async (event: ChangeEvent<HTMLInputElement>) => {\n    const files = Array.prototype.slice.call(event.target.files)\n    try {\n      setBase64(null)\n      setCanvasSize(initialCanvasSize)\n      const _base64 = await convertBlobToBase64(files[0])\n      setBase64(_base64)\n      const aspectRatio = await getAspectRatioOfBase64(_base64)\n      setCanvasSize(prev => ({ ...prev, width: prev.width * aspectRatio }))\n    } catch (err) {\n      alert(err.message)\n    }\n  }, [])\n\n  const handleDownload = useCallback((event: SyntheticEvent<HTMLButtonElement>) => {\n    const stageElement: any = event.currentTarget.previousElementSibling\n    if (!stageElement) {\n      alert('Download failed')\n      return\n    }\n    const app = stageElement.app\n    const _base64 = app.renderer.plugins.extract.base64(app.stage)\n    download(_base64, 'image.jpg')\n  }, [])\n\n  const handlePile = useCallback((event: ChangeEvent<HTMLInputElement>) => {\n    const value = event.currentTarget.value\n    setPile(+value)\n  }, [])\n\n  const downloadButton = useMemo(\n    () => (\n      <DownloadSection>\n        <button onClick={handleDownload}>Download</button>\n      </DownloadSection>\n    ),\n    []\n  )\n\n  return (\n    <>\n      <Container>\n        <InputSection>\n          <input type=\"file\" accept=\"image/*\" onChange={handleFiles} />\n          <label>\n            Pile: <input type=\"range\" min=\"1\" max=\"10\" value={pile} onChange={handlePile} />\n          </label>\n        </InputSection>\n        <FiltersSection>\n          <FilterSection>\n            <h2>Before</h2>\n            <Stage {...canvasSize}>{base64 && <Sprite image={base64} {...canvasSize} />}</Stage>\n          </FilterSection>\n          <FilterSection>\n            <h2>Kuwahara Filter</h2>\n            <Stage {...canvasSize}>\n              {base64 && <Sprite image={base64} filters={[...Array(pile)].map(() => KuwaharaFilter)} {...canvasSize} />}\n            </Stage>\n            {base64 && downloadButton}\n          </FilterSection>\n          <FilterSection>\n            <h2>Bilateral Filter</h2>\n            <Stage {...canvasSize}>\n              {base64 && (\n                <Sprite image={base64} filters={[...Array(pile)].map(() => BilateralFilter)} {...canvasSize} />\n              )}\n            </Stage>\n            {base64 && downloadButton}\n          </FilterSection>\n        </FiltersSection>\n      </Container>\n    </>\n  )\n}\n","import * as PIXI from 'pixi.js'\nimport { useMemo } from 'react'\nimport { bilateral, kuwahara } from '../shader'\n\ninterface Props {\n  width: number\n  height: number\n}\n\nexport default function useFilter({ width, height }: Props) {\n  const uniforms = useMemo(\n    () => ({\n      resolution: {\n        type: 'v2',\n        value: [width, height],\n      },\n    }),\n    [width, height]\n  )\n\n  const KuwaharaFilter = useMemo(() => new PIXI.Filter('', kuwahara, uniforms), [uniforms])\n  const BilateralFilter = useMemo(() => new PIXI.Filter('', bilateral, uniforms), [uniforms])\n\n  return {\n    KuwaharaFilter,\n    BilateralFilter,\n  }\n}\n","import React from 'react'\nimport styled, { createGlobalStyle } from 'styled-components'\nimport reset from 'styled-reset'\nimport Filters from './Filters'\n\nconst GlobalStyle = createGlobalStyle`\n  ${reset}\n`\n\nconst Title = styled.h1`\n  font-size: 36px;\n  font-weight: bold;\n  text-align: center;\n  line-height: 1.5;\n  padding: 24px 0;\n`\n\nexport default function App() {\n  return (\n    <>\n      <Title>Image Filters</Title>\n      <Filters />\n    </>\n  )\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n)\n\ninterface Config {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL((process as { env: { [key: string]: string } }).env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker === null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (response.status === 404 || (contentType !== null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.')\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}